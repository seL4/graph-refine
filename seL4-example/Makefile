#
# Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
#
# SPDX-License-Identifier: BSD-2-Clause
#

# Makefile for building, decompiling & validating seL4.

# n.b. doesn't track the dependencies of the custom tools
# (e.g. standalone c-parser and decompiler) properly, so may not know to
# rebuild if a custom tool is updated.

ifndef CONFIG_OPTIMISATION_LEVEL
  CONFIG_OPTIMISATION_LEVEL := -O1
endif

ifndef GREF_ROOT
  GREF_ROOT := $(realpath $(dir $(lastword ${MAKEFILE_LIST}))..)
endif

L4V_CONFIG := ${L4V_ARCH}$(if ${L4V_FEATURES},-${L4V_FEATURES},)
TARGET_NAME := ${L4V_CONFIG}${CONFIG_OPTIMISATION_LEVEL}

ifndef TARGET_DIR
  TARGET_DIR := target/${TARGET_NAME}
endif

# We build our own kernel locally, so we can store builds
# according to their optimisation levels.
KERNEL_BUILD_ROOT := build/${TARGET_NAME}
KERNEL_CMAKE_EXTRA_OPTIONS := -DKernelOptimisation=${CONFIG_OPTIMISATION_LEVEL}
include ${GREF_ROOT}/../l4v/spec/cspec/c/kernel.mk

# However, CFunctions.txt depends on l4v's kernel build.
# FIXME: the l4v build directory should really depend on L4V_FEATURES.
L4V_KERNEL_BUILD_DIR := build/${L4V_ARCH}
L4V_KERNEL_BUILD_PATH := ${CSPEC_DIR}/c/${L4V_KERNEL_BUILD_DIR}

DECOMP_SCRIPT := ${GREF_ROOT}/decompiler/decompile
${DECOMP_SCRIPT}:
	@echo "No decompiler found. Use setup-decompiler.py to install one." >&2
	@exit 1

# Compile and decompile

KERNEL_FILES := kernel.elf.rodata kernel.elf.txt kernel.elf.symtab kernel_all.c_pp kernel.sigs kernel.elf
KERNEL_PATHS := $(patsubst %, $(TARGET_DIR)/%, $(KERNEL_FILES))

${KERNEL_PATHS}: ${TARGET_DIR}/%: ${KERNEL_BUILD_ROOT}/%
	@mkdir -p ${TARGET_DIR}
	cp $< $@

${L4V_KERNEL_BUILD_PATH}/kernel_all.c_pp: ${KERNEL_DEPS} ${CONFIG_DOMAIN_SCHEDULE}
	MAKEFILES= make -C ${CSPEC_DIR}/c ${L4V_KERNEL_BUILD_DIR}/kernel_all.c_pp

# A quick check that the two kernel builds produce the same C source
${TARGET_DIR}/.diff: ${L4V_KERNEL_BUILD_PATH}/kernel_all.c_pp ${KERNEL_BUILD_ROOT}/kernel_all.c_pp
	diff -q --ignore-matching-lines='^#' $^
	@mkdir -p ${TARGET_DIR}
	@touch $@

diff: ${TARGET_DIR}/.diff
.PHONY: diff

AUIPC_FIXUP := ${GREF_ROOT}/scripts/check_addr.py
ASM_FUNCTIONS_DEPS := ${TARGET_DIR}/kernel.elf.txt ${TARGET_DIR}/kernel.sigs ${DECOMP_SCRIPT} ${AUIPC_FIXUP}
ASM_FUNCTIONS := ${TARGET_DIR}/ASMFunctions.txt
ASM_FUNCTIONS_OUT := ${ASM_FUNCTIONS} ${TARGET_DIR}/kernel_output.txt

IGNORE_ARM := _start,c_handle_fastpath_call,c_handle_fastpath_reply_recv,restore_user_context

${ASM_FUNCTIONS_OUT} &: ${ASM_FUNCTIONS_DEPS}
	${DECOMP_SCRIPT} ${TARGET_DIR}/kernel --ignore=${IGNORE_${L4V_ARCH}}
	mv ${TARGET_DIR}/kernel_mc_graph.txt ${ASM_FUNCTIONS}.tmp
	if [ "${L4V_ARCH}" = RISCV64 ]; then \
	  python2 ${AUIPC_FIXUP} ${ASM_FUNCTIONS}.tmp ${TARGET_DIR}/kernel.elf.txt ${ASM_FUNCTIONS}.tmp2 >/dev/null; \
	  mv ${ASM_FUNCTIONS}.tmp2 ${ASM_FUNCTIONS}.tmp; \
	  sed -i 's/sfence_vma/sfence.vma/g' ${ASM_FUNCTIONS}.tmp; \
	fi
	mv ${ASM_FUNCTIONS}.tmp ${ASM_FUNCTIONS}

C_FUNCITONS_DEPS := \
  ${L4V_KERNEL_BUILD_PATH}/kernel_all.c_pp \
  ${L4V_REPO_PATH}/tools/asmrefine/*.thy \
  ${L4V_REPO_PATH}/tools/asmrefine/${L4V_ARCH}/*.thy

${TARGET_DIR}/CFunctions.txt: ${C_FUNCTIONS_DEPS}
	@mkdir -p ${TARGET_DIR}
	MAKEFILES= make -C ${L4V_REPO_PATH}/proof/ SimplExport
	# FIXME: the following path should really depend on L4V_FEATURES.
	cp ${L4V_REPO_PATH}/proof/asmrefine/export/${L4V_ARCH}/CFunDump.txt $@

STACK_BOUNDS := ${GREF_ROOT}/scripts/stack_bounds.py
${TARGET_DIR}/StackBounds.txt: ${ASM_FUNCTIONS} ${TARGET_DIR}/kernel.elf.txt ${STACK_BOUNDS}
	${STACK_BOUNDS} --asm-functions ${ASM_FUNCTIONS} --elf-txt ${TARGET_DIR}/kernel.elf.txt > $@

${TARGET_DIR}/target.py: target-${L4V_ARCH}.py
	@mkdir -p ${TARGET_DIR}
	cp target-${L4V_ARCH}.py $@

${TARGET_DIR}/functions.txt: ${TARGET_DIR}/ASMFunctions.txt ${TARGET_DIR}/CFunctions.txt
	${GREF_ROOT}/scripts/list_functions.py ${TARGET_DIR} > $@

# Convenience target for GitHub CI.
# Includes all graph-refine inputs except CFunctions.txt, which is generated by a separate workflow.
ci_target: ${KERNEL_PATHS} ${ASM_FUNCTIONS_OUT} ${TARGET_DIR}/StackBounds.txt ${TARGET_DIR}/target.py

.PHONY: ci_target

GRAPH_REFINE_INPUTS := \
  ${TARGET_DIR}/kernel.elf.rodata \
  ${TARGET_DIR}/kernel.elf.symtab \
  ${TARGET_DIR}/ASMFunctions.txt \
  ${TARGET_DIR}/CFunctions.txt \
  ${TARGET_DIR}/target.py \
  ${GREF_ROOT}/*.py

GRAPH_REFINE := python2 ${GREF_ROOT}/graph-refine.py

${TARGET_DIR}/demo-report.txt: ${TARGET_DIR}/StackBounds.txt ${GRAPH_REFINE_INPUTS}
	${GRAPH_REFINE} ${TARGET_DIR} trace-to:$@.partial deps:Kernel_C.cancelAllIPC
	mv $@.partial $@

${TARGET_DIR}/report.txt: ${TARGET_DIR}/StackBounds.txt ${GRAPH_REFINE_INPUTS}
	${GRAPH_REFINE} ${TARGET_DIR} trace-to:$@.partial all
	mv $@.partial $@

${TARGET_DIR}/coverage.txt: ${TARGET_DIR}/StackBounds.txt ${GRAPH_REFINE_INPUTS}
	${GRAPH_REFINE} ${TARGET_DIR} trace-to:$@.partial coverage
	mv $@.partial $@

report: ${TARGET_DIR}/report.txt
coverage: ${TARGET_DIR}/coverage.txt
StackBounds: ${TARGET_DIR}/StackBounds.txt

.PHONY: report coverage StackBounds

default: report

.PHONY: .FORCE
.FORCE:

# WCET (worst-case execution time) targets

GTG := ${GREF_ROOT}/graph-to-graph/
TARGET_DIR_ABS := $(realpath TARGET_DIR)

${TARGET_DIR}/loop_counts_1.py: ${TARGET_DIR}/StackBounds.txt ${GRAPH_REFINE_INPUTS}
	cd ${GTG} && python graph_to_graph.py ${TARGET_DIR_ABS} handleSyscall --l
	cp ${TARGET_DIR}/loop_counts.py $@

${TARGET_DIR}/lb_reports/report_%.txt: ${TARGET_DIR}/loop_counts_1.py
	@mkdir -p ${TARGET_DIR}/lb_reports
	cd ${GTG} && python convert_loop_bounds.py --worker-id $* ${TARGET_DIR_ABS} &> ${TARGET_DIR_ABS}/lb_reports/pre-report_$*.txt
	tail -n 500 ${TARGET_DIR}/lb_reports/pre-report_$*.txt > $@
	rm ${TARGET_DIR}/lb_reports/pre-report_$*.txt

ALL_LB_REPORTS := $(patsubst %, ${TARGET_DIR}/lb_reports/report_%.txt, 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 )

${TARGET_DIR}/lb_reports/fin_report.txt: ${ALL_LB_REPORTS}
	cd ${GTG} && python convert_loop_bounds.py $* ${TARGET_DIR_ABS} &> ${TARGET_DIR_ABS}/lb_reports/pre-freport.txt
	mv ${TARGET_DIR}/lb_reports/pre-freport.txt $@

lb: ${TARGET_DIR}/lb_reports/fin_report.txt
